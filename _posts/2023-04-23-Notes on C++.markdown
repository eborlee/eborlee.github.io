---
layout:     post
title:      "Notes - C++ Learning | C++学习笔记"
subtitle:   " \"C++ Primer Plus / Effective C++ / Numerical Methods / My Notes...\""
date:       2023-09-09 12:00:00
author:     "Yibo Li"
header-img: "img/post-bg-2015.jpg"
multilingual: false
catalog: true
tags:
    - C++
    - Quant
    - Notes
---

> “Within C++, there is a much smaller and cleaner language struggling to get out.”


# Notes - C++ Learning | C++学习笔记

2023-05-08

Yibo Li

yli12@stevens.edu; yiboli@link.cuhk.edu.hk

http://eborlee.github.io

## Table Of Contents


* TOC
{:toc}


# Book: Numerical Methods in Finance with C++

## 1 Basic Usages

- It is a best practice to almost always set your destructors to be virtual.
- const double getK() and double getK() const: 后者为常量成员函数，无法修改对象的任何成员变量，除非该变量被声明为mutable。





## 1 Binomial Pricer

#### Ways of passing parameters:

1. Passed By Value: double S(double S0, double U, ...)

   When a function is called, a copy of that variable is made in a separate location in computer memory. The func could see and change the copy, but has no access to the original varible. And the calling program could also see the copy and only has access to the original variable.

2. Passed By Reference: int GetInputData(double& S0, ...)

   C++ can return only a single value in a function and this way enables to pass all the inputs back to the program.

   In this case, a single copy of the variable in computer memory is shared by the function and the calling program.

   

---

#### Separate Compilation

After defining some function protoptypes in .h file: changes to one of the .cpp files do not require the other file to be recompiled as long as the function prototypes remain unchanged. In large projects this can mean considerable savings in compilation time.

## 2 Binomial Pricer Revisited



## 3 American Options

### 3.1 Multiple Inheritance

***<u>菱形继承问题的解决方案：</u>***

- 1.Virtual Inheritance
- 2.作用域解析运算符
- 3.重新定义函数

```c++
#include <iostream>
using namespace std;

class A
{
public:
    void func(){
        cout<<"This is A"<<endl;
    };
};

class B: virtual public A{
    public:
    void func() {
        cout<<"This is B"<<endl;
    };

};
class C: virtual public A{
    public:
    void func() {
        cout<<"This is C"<<endl;
    };
};

class D: public B, public C{
    public:
    void func() {
        cout<<"This is D"<<endl;
    }
};

class E: public B, public C{
    // E不给实现，就会导致二义性，编译器不知道该找哪个方法
};

class F: public B, public C{
    public:
    void func(){
        C::func();
    }
};

int main(){
    
    D d;
    E e;
    d.func();
    // e.func(); // 二义性，无法编译 对比python，python是运行时报错，基于MRO。

    // 方法2 作用域解析运算符
    e.B::func();

    // 方法3 重新定义函数
    F f;
    f.func();
    
}
```

题外话，对比python，python对于菱形继承，D继承自BC，而D没有给方法实现，第一python的多重继承和方法解析是在运行时进行，而不是在编译时。第二，python的MRO(Method Resolution Order)算法会根据MRO顺序来决定使用哪个方法，除非明确调用不存在的方法和属性。

```python
class A:
  def func(self):
    print("A")

class B(A):
  def func(self):
    print("B")
class C(A):
  def func(self):
    print("C")
    
class D(B,C):
	pass

d = D()
d.func() # 输出B

print(D.mro())

```



3.2 Virtual Inheritance

3.3 Class Templates

## 4 Non-linear Solvers

**Basic Knowledge:**

BSM Formula:
$$
C(S_0, K, T,\sigma,r)=S_0N(d_+)-Ke^{-rT}N(d_-)\\
d_+=\frac{ln(\frac{S_0}{K})+(r+\frac{\sigma^2}{2})T}{\sigma\sqrt{T}}\\
d_-=d_+-\sigma\sqrt{T}\\
N(x)=\int_{-\infty}^x \frac{1}{\sqrt{2\pi}}e^{-\frac{y^2}{2}}dy
$$
If the values of S0, K, T, σ,r are all known, then we can calculate the price of option. Among these items, only σ is not known and needed to be estimated using the market option price.

There are two common methods for this purpose: Bisection method and Newton-Raphson method.



**Bisection Method:**

We want to compute a solution x to an equation: f(x) = c, where f is a given function from an interval [a,b] to R. It is assumed that f is continuous on [a,b] and f(a)-c, f(b)-c have opposite signs. Then there must be an x∈[a,b] such that f(x)=c.

The bisection method works by constructing sequences l, r of left and right approximations by induction:

(l+r)/2 -> mid, f(mid)-c

If f(l) * f(mid) > 0, root lies in [mid, r], mid -> l;

If f(l) * f(mid) <0, root lies in [l, mid], mid ->r;

If f(mid) == 0, mid is the root, Stop.

And if |mid - l | <=  Accuracy requirement, stop. Input the mid and the corresponding f(mid)-c at that moment.


**Newton-Raphson Method:**

f is assumed to be differentiable on [a,b] and construct a sequence xn as follows:
$$
Take ~x0∈(a,b).\\
For~ n=0,1,2,..., let\\
x_{n+1}=x_n-\frac{f(x_n)-c}{f'(x_n)}
$$
If the equation f(x)=c has a solution x∈(a,b) such that f'(x)≠0 and x0 is chosen close enough to x, then xn will converge to x.

### 4.1 使用Function Pointer的基本实现

```c++
#ifndef Solver01_h
#define Solver01_h

double SolveByBisect(double (*Fct)(double x), double Tgt,
                     double LEnd, double REnd, double acc)
{
    double left = LEnd, right = REnd, mid = (left + right) / 2;
    double y_left = Fct(left) - Tgt, y_mid = Fct(mid) - Tgt;
    while (mid - left > acc)
    {
        if ((y_left > 0 && y_mid > 0) || (y_left < 0 && y_mid < 0))
        {
            left = mid;
            y_left = y_mid;
        }
        else
            right = mid;
        mid = (left + right) / 2;
        y_mid = Fct(mid) - Tgt;
    }
    return mid;
}

// Newton-Raphson Method
double SolveByNR(double (*Fct)(double x), double (*DFct)(double x), double Tgt,
                 double guess, double acc)
{
    double x_prev = guess;
    double x_next = x_prev - (Fct(x_prev) - Tgt) / DFct(x_prev);
    while (x_next - x_prev > acc || x_prev - x_next > acc)
    {
        x_prev = x_next;
        x_next = x_prev - (Fct(x_prev) - Tgt) / DFct(x_prev);
    }
    return x_next;
}

#endif
```

```c++
#include "Solver01.h"
#include <iostream>
using namespace std;

double F1(double x){return x*x-2;}
double DF1(double x){return 2*x;}

int main(){
    double Acc = 0.001;
    double LEnd=0.0, REnd=2.0;
    double Tgt = 0.0;
    cout << "Root of F1 by bisect:"
         << SolveByBisect(F1, Tgt, LEnd, REnd, Acc)
         <<endl;
    double Guess = 1.0;
    cout << "Root of F1 by newton-raphson:"
         << SolveByNR(F1, DF1, Tgt, Guess, Acc)
         <<endl;

    return 0;
}
```

这种方式简单却不易于expansion。如果传入的Function形如f(x)没问题，但是f(x,a) = x^2-a不适用。

### 4.2 **使用Virtual Functions**: Enable dynamic binding

Dynamic Binding :动态联编是指在运行时根据实际对象的类型来确定要调用的函数实现，而不仅仅根据指针或引用的静态类型。这意味着，当通过基类的指针或引用调用虚函数时，实际调用的是对象的派生类中所重写的虚函数。这种动态绑定机制使得在继承体系中可以实现多态性，允许通过基类的接口来操作具体的派生类对象，而不需要显式指定对象的具体类型。

而如果在签名中声明为类对象本身而不是其指针，就会导致： <mark>虽然可以传入其子类，但是调用方法还是调用的同一个父类方法，而不会调用子类重写的方法。</mark>

```c++
#include <iostream>

class Animal {
public:
    virtual void MakeSound() {
        std::cout << "Animal is making a sound" << std::endl;
    }
};

class Dog : public Animal {
public:
    void MakeSound() override {
        std::cout << "Dog is barking" << std::endl;
    }
};

class Cat : public Animal {
public:
    void MakeSound() override {
        std::cout << "Cat is meowing" << std::endl;
    }
};

void PerformSound(Animal* animal) {
    animal->MakeSound();
}

void PerformSound2(Animal animal) {
    animal.MakeSound();
}

int main() {
    Animal animal;
    Dog dog;
    Cat cat;
    // 当使用基类指针作为参数时，可以实现运行时的多态性，使代码能够根据实际传递的派生类对象来选择相应的函数实现。
    // dynamic binding
    PerformSound(&animal); // Output: "Animal is making a sound"
    PerformSound(&dog);    // Output: "Dog is barking"
    PerformSound(&cat);    // Output: "Cat is meowing"

    // 如果直接传递基类对象本身，编译器在编译时就确定了要调用的函数实现，无法在运行时动态选择不同的函数实现。
    PerformSound2(animal); // Output: "Animal is making a sound"
    PerformSound2(dog);    // Output: "Animal is making a sound"
    PerformSound2(cat);    // Output: "Animal is making a sound"
    return 0;
}

```

继续Solver的例子：

```c++
#ifndef Solver02_h
#define Solver02_h

class Function
{
public:
    virtual double Value(double x) = 0;
    virtual double Deriv(double x) = 0;
};

double SolveByBisect(Function *Fct, double Tgt, double LEnd, double REnd, double Acc)
{
    double left = LEnd, right = REnd, mid = (left + right) / 2;
    double y_left = Fct->Value(left) - Tgt, y_mid = Fct->Value(mid) - Tgt;
    while (mid - left > Acc)
    {
        if ((y_left > 0 && y_mid > 0) || (y_left < 0 && y_mid < 0))
        {
            left = mid;
            y_left = y_mid;
        }
        else
            right = mid;
        mid = (left + right) / 2;
        y_mid = Fct->Value(mid) - Tgt;
    }
    return mid;
}

double SolveByNR(Function *Fct, double Tgt, double guess, double acc)
{
    double x_prev = guess;
    double x_next = x_prev - (Fct->Value(x_prev) - Tgt) / Fct->Deriv(x_prev);
    while (x_next - x_prev > acc || x_prev - x_next > acc)
    {
        x_prev = x_next;
        x_next = x_prev - (Fct->Value(x_prev) - Tgt) / Fct->Deriv(x_prev);
    }
    return x_next;
}

#endif
```

```c++
#include "Solver02.h"
#include <iostream>
using namespace std;

class F1 : public Function
{
public:
     double Value(double x) { return x * x - 2; }
     double Deriv(double x) { return 2 * x; }
} MyF1;

class F2 : public Function
{
private:
     double a;

public:
     F2(double a_)
     {
          a = a_;
     }
     double Value(double x) { return x * x - a; }
     double Deriv(double x) { return 2 * x; }
} MyF2(3.0);

int main()
{
     double Acc = 0.001;
     double LEnd = 0.0, REnd = 2.0;
     double Tgt = 0.0;
     cout << "Root of F1 by bisect:"
          << SolveByBisect(&MyF1, Tgt, LEnd, REnd, Acc)
          << endl;
     double Guess = 1.0;
     cout << "Root of F2 by newton-raphson:"
          << SolveByNR(&MyF2, Tgt, Guess, Acc)
          << endl;

     return 0;
}
```

使用虚函数在运行时进行动态绑定是有一些开销的，这是因为动态绑定需要在运行时查找正确的函数实现。这些开销包括：

1. 虚函数表（vtable）：为了实现动态绑定，编译器会为每个包含虚函数的类生成一个虚函数表。虚函数表是一个指针数组，用于存储每个虚函数的地址。对于每个类对象，都会包含一个指向其虚函数表的指针。这样，当调用虚函数时，需要通过指针查找正确的函数地址。
2. 虚函数调用开销：调用虚函数时，需要通过指针间接调用函数。这涉及额外的间接跳转操作，相对于直接调用非虚函数，会增加一定的开销。

总体来说可以忽略不计，但是以下情景需要注意：

1. <u>循环中使用虚函数会造成大量开销</u>
2. 使用虚函数的地方可以进行性能优化，例如使用内联（inline）修饰符来尝试避免间接跳转的开销。
3. 考虑使用其他的技术，如模板和策略模式，来避免使用虚函数带来的开销。

### 4.3 使用Templates模板

**极大的保留了虚函数的优点，但是将type checking从runtime转移到了compile time.**

代码与虚函数大体相似，但简化了：不需要定义抽象基类和其虚函数，具体的公式类也不需要再继承共同的父类。

缺点：如果有大量的函数将会带来较长的编译时间和较大的.exe文件。

```c++
#ifndef Solver03_h
#define Solver03_h

template <typename Function>
double SolveByBisect(Function *Fct, double Tgt, double LEnd, double REnd, double Acc)
{
    double left = LEnd, right = REnd, mid = (left + right) / 2;
    double y_left = Fct->Value(left) - Tgt, y_mid = Fct->Value(mid) - Tgt;
    while (mid - left > Acc)
    {
        if ((y_left > 0 && y_mid > 0) || (y_left < 0 && y_mid < 0))
        {
            left = mid;
            y_left = y_mid;
        }
        else
            right = mid;
        mid = (left + right) / 2;
        y_mid = Fct->Value(mid) - Tgt;
    }
    return mid;
}

template <typename Function>
double SolveByNR(Function *Fct, double Tgt, double guess, double acc)
{
    double x_prev = guess;
    double x_next = x_prev - (Fct->Value(x_prev) - Tgt) / Fct->Deriv(x_prev);
    while (x_next - x_prev > acc || x_prev - x_next > acc)
    {
        x_prev = x_next;
        x_next = x_prev - (Fct->Value(x_prev) - Tgt) / Fct->Deriv(x_prev);
    }
    return x_next;
}

#endif
```

此时这两个solver函数都是模板函数，即可以接收任意类型的Fct，编译器会在将来这个函数被调用时，根据调用的那句话中声明的typename的类型，来生成不同版本的函数，这样就避免了运行时开销。比如template<typename T> void print(T value){...}, 将来调用的时候，print<int>(42); print<double> (42.0); 就会生成不同版本的函数。

编译器针对已知的类型，更好的进行优化；编译器更容易进行内联优化；没有虚函数的运行时开销；生成更好的分支预测代码。 

```c++
#include "Solver03.h"
#include <iostream>
using namespace std;

class F1
{
public:
     double Value(double x) { return x * x - 2; }
     double Deriv(double x) { return 2 * x; }
} MyF1;

class F2
{
private:
     double a;

public:
     F2(double a_)
     {
          a = a_;
     }
     double Value(double x) { return x * x - a; }
     double Deriv(double x) { return 2 * x; }
} MyF2(3.0);

int main()
{
     double Acc = 0.001;
     double LEnd = 0.0, REnd = 2.0;
     double Tgt = 0.0;
     cout << "Root of F1 by bisect:"
          << SolveByBisect(&MyF1, Tgt, LEnd, REnd, Acc)
          << endl;
     double Guess = 1.0;
     cout << "Root of F2 by newton-raphson:"
          << SolveByNR(&MyF2, Tgt, Guess, Acc)
          << endl;

     return 0;
}
```



同时，由于不再使用虚函数，SolveByBisect和SolveByNR的声明也不需要再使用Fct指针，使用Fct就可以了。



### 4.4 Computing Implied Volatility

Define EurCall.h for computing the call option price using BSM using solver03.h, i.e. Templates version.

To compute it using Newton-Raphson method, we also need an expression for the derivative of the European call option price with respect to volatility σ calculated from BSM formula, **Vega**, is given by:
$$
v=\frac{1}{\sqrt{2\pi}}S_0e^{\frac{-d_+^2}{2}}
$$


```c++
#ifndef EurCall_h
#define EurCall_h

class EurCall
{
public:
    double T, K;
    EurCall(double T_, double K_) { T = T_, K = K_; }

    double d_plus(double S0, double sigma, double r);
    double d_minus(double S0, double sigma, double r);
    double PriceByBSFormula(double S0, double sigma, double r);

    double VegaByBSFormula(double S0, double sigma, double r);
};

#endif
```

Implement the methods in EurCall.cpp:

```c++
#include "EurCall.h"
#include <cmath>
#include <iostream>
using namespace std;
double N(double x)
{
    double result;

    if (x > 0)
    {
        result = 0.5 * (1.0 + erf(x / std::sqrt(2.0)));
    }
    else if (x == 0)
    {
        result = 0.5;
    }
    else
    {
        result = 0.5 * (1.0 - erf(-x / std::sqrt(2.0)));
    }

    return result;
}

double EurCall::d_plus(double S0, double sigma, double r)
{
    return (log(S0 / K) + (r + 0.5 * pow(sigma, 2.0)) * T) / (sigma * sqrt(T));
}

double EurCall::d_minus(double S0, double sigma, double r)
{
    return d_plus(S0, sigma, r) - sigma * sqrt(T);
}

double EurCall::PriceByBSFormula(double S0, double sigma, double r)
{
    return S0 * N(d_plus(S0, sigma, r)) - K * exp(-r * T) * N(d_minus(S0, sigma, r));
}

double EurCall::VegaByBSFormula(double S0, double sigma, double r)
{
    double pi = 4.0 * atan(1.0);
    return S0 * exp(-d_minus(S0, sigma, r) * d_plus(S0, sigma, r) / 2) * sqrt(T) / sqrt(2.0 * pi);
}
```

Run the functions in main_for_cal_imp.cpp. Here create a class as a intermediary class to translate the functions from EurCall to Solvers.

```c++
#include "Solver03.h"
#include "EurCall.h"
#include "EurCall.cpp"
#include <iostream>
using namespace std;

// 需要一个中间类进行初始化和翻译函数名
class Intermediary : public EurCall
{
private:
    double S0, r;

public:
    Intermediary(double S0_, double r_, double T_, double K_) : EurCall(T_, K_)
    {
        S0 = S0_;
        r = r_;
    }

    double Value(double sigma)
    {
        return PriceByBSFormula(S0, sigma, r);
    }

    double Deriv(double sigma)
    {
        return VegaByBSFormula(S0, sigma, r);
    }
};

int main()
{
    double S0 = 100.0;
    double r = 0.1;
    double T = 1.0;
    double K = 100.0;
    Intermediary Call(S0, r, T, K);

    double Acc = 0.001;
    double LEnd = 0.01, REnd = 1.0;
    double Tgt = 12.56;

    cout << "Root of F1 by bisect:"
         << SolveByBisect(&Call, Tgt, LEnd, REnd, Acc)
         << endl;
    double Guess = 0.23;
    cout << "Root of F2 by newton-raphson:"
         << SolveByNR(&Call, Tgt, Guess, Acc)
         << endl;

    return 0;
}
```



## 5 Monte Carlo methods

### LU Decomposition



```c++
#include <iostream>
#include <Eigen/Dense>
#include <Eigen/LU>
using namespace std;
using namespace Eigen;

int main(){
    typedef Matrix<double, 4,4> Matrix4x4;

    Matrix4x4 p;

    p<< 7,3,-1,2,
        3,8,1,-4,
        -1,1,4,-1,
        2,-4,-1,6;

    cout<< "Mat_P:\n"<<p<<endl<<endl;


    PartialPivLU<Matrix4x4> lu(p); // 此处在栈区创建了一个PPL对象，其构造函数自动对传入矩阵进行LU分解

    cout<< "Lu_Mat:\n"<<lu.matrixLU()<< endl<<endl;

    // 由于lu分解的下三角矩阵的主对角线都是1，所以需要先初始化一个单位矩阵
    // 使用到了静态函数
    Matrix4x4 l = MatrixXd::Identity(4,4);
    // 先获取一个从0，0开始的4*4的子矩阵再限定其视图为下三角，接受赋值
    l.block<4,4>(0,0).triangularView<StrictlyLower>() = lu.matrixLU();
    cout<<"L_mat:\n"<<l<<endl<<endl;

    // 由于上三角矩阵的主对角线是0，所以直接接受赋值
    Matrix4x4 u = lu.matrixLU().triangularView<Upper>();
    cout<<"u_mat:\n"<<u<<endl<<endl;
```





# C++ Primer Plus

## Chapter 4. 复合类型

### 4.8 指针、数组和指针算术

- 指针变量+1后，增加量等于其指向类型的字节数。
- C++将数组名解释为第一个元素的地址, 被解释为这个元素的指针。但本身是一个标识符，不是真正的指针
- *(stacks + 1)  <==> stacks[1]
- 对数组使用sizeof得到整个数组的长度，而对指针应用sizeof得到的是指针的字节长度，即使指针指向一个数组。
- 数组名：首个元素的地址， &数组名：整个数组的地址。数字上这两个地址相同，但是数组名是一个元素字节长度内存块的地址，而&数组名是一个数组整个长度字节内存块的地址。

```c++
// C++将数组名解释为数组第一个元素的地址
// wages = &wages[0] = address of first element of array
double wages[3] = {10.0, 20.0, 30.0};
short stacks[3] = {3, 2, 1};
double * pw = wages;
short * ps = &stacks[0];

cout << "pw=" << pw << ", *pw=" << *pw << endl;

pw = pw + 1;
cout << "pw=" << pw << ", *pw=" << *pw << endl;
cout << "ps=" << ps << ", *ps=" << *ps << endl;
cout << "stacks[0]=" << stacks[0] << ", stacks[1]=" << stacks[1] << endl;

cout << "*stacks=" << *stacks << ", *(stacks+1)=" << *(stacks+1) << endl;

cout<<sizeof(wages)<<endl;
cout<<sizeof(pw)<<endl;

// 数组名：首个元素的地址， &数组名：整个数组的地址
cout<<stacks<< ", "<<&stacks<<endl;
```

```c++
// output
pw=0x7ff7b61391f0, *pw=10
pw=0x7ff7b61391f8, *pw=20
ps=0x7ff7b61391e2, *ps=3
stacks[0]=3, stacks[1]=2
*stacks=3, *(stacks+1)=2
24
8
 0x7ff7bb3e61e2, 0x7ff7bb3e61e2
```



```c++
short tell[10];
short (*pas)[10] = &tell;
//(*pas)[i] 的意思是“解引用指针 pas 得到一个数组，然后访问该数组的第 i 个元素”
cout<<pas<<endl; // 指针指向的地址
cout<<pas[0]<<endl; // 也是首元素的地址
cout<<pas[1]<<endl; // 跳过1个数组，但指向了未定义的内存地址
cout<<*pas<<endl; // 解引用，数组的首元素的地址
cout<<(*pas)[0]<<endl; // 解引用之后获取第一个元素的值
cout<<*(*pas)<<endl; // 第一次解引用获取一个数组的指针，对数组指针再次解引用

//output
>>> 
0x7ff7b0bb61d0
0x7ff7b0bb61d0
0x7ff7b0bb61e4
0x7ff7b0bb61d0
-28656
-28656
```

在这个特定的情境下，`pas` 是一个指向长度为10的 `short` 数组的指针。对于 `pas[1]` 的解释在于，编译器认为你想跳过第一个长度为10的 `short` 数组，然后到达第二个这样的数组。当然，在这个特定的例子中，第二个这样的数组并不存在，所以 `pas[1]` 会指向一个未定义的内存区域。

通常，`pointer_to_array[n]` 的意义是“跳过 `n` 个数组，到达第 `n+1` 个数组的起始地址”，这里的数组是 `pointer_to_array` 指针所指向的类型。所以 `pas[1]` 就是 `tell` 数组后面 10（数组长度）个 `short` 类型大小的位置的地址。这通常是一个不安全的操作，因为这个地址可能没有被程序合法地分配。访问这个地址通常会导致未定义的行为。

此外，sizeof(pointer)与sizeof(*sizeof)也是不同的。前者是查询储存该指针本身所需的字节长度，比如4字节或8字节。而后者是查询指针指向的数据类型的大小。



###### keyword `static`

在类定义中直接声明的变量通常是非静态成员变量。每个类的对象都有其自己的一份非静态成员变量的拷贝。相对的，静态成员变量是属于类本身的，不属于对象，所有该类的对象共享同一份静态成员变量。

```c++
class Example {
public:
    int a; // 非静态成员变量
    static int b; // 静态成员变量
};
```

非常量引用不可绑定或传入常量：

当一个引用没有被const修饰，不能用这个引用去绑定常量值，因为这意味着你可能会通过这个引用来修改引用的值，但是这与常量不可变的特性是冲突的，如：

```c++
const int x = 10;
// invalid
int &ref = x;

void func(int &a){};
const int constVar = 10;
int nonConstVar = 10;

func(constVar); // invalid
func(nonConstVar); // valid
```



# My Notes

#### keyword const

1）创建变量时修饰： const Example obj；

目的：

- 对象的所以非static成员变量都不可被修改，除非是被mutable修饰的。
- 限制为const的对象只能调用const函数，确保成员函数不会修改对象的状态；
- 当对象作为函数的参数被传入时，确保函数不会修改该对象；
- 有时会对函数返回的对象使用const；
- 明确语义；

2）函数形参const：void func(const &int a)

3）函数声明末尾const：void func(int a) const



#### Member Initialization List 成员初始化列表

不可用于static变量



智能指针



性能优化的一些建议

> 引用传递: 除非有特殊需求，大型对象（例如std::vector, std::deque等）应尽量通过引用进行传递，以避免不必要的拷贝。
>
> const修饰: 如果某个参数或者成员函数不会对对象的状态进行修改，使用const关键字。这样能让编译器进行一些优化，并且使代码更安全。
>
> 预分配内存: 如果知道容器将要存储的元素数量，考虑预先分配容器大小（如std::vector::reserve）。
>
> 函数内联: 对于那些小型且频繁调用的函数，考虑使用内联（inline）以减少函数调用的开销。
>
> 优化数据结构: 考虑数据访问模式，使用最适合的数据结构。例如，在大量查找操作中使用哈希表。
>
> 避免全局变量: 全局变量会影响代码的模块性和可预测性，应尽量避免。
>
> 多线程: 如果有一些独立的计算密集型任务，可以考虑使用多线程进行优化。
>
> 算法复杂性: 选择时间复杂性更优的算法可以大幅提升程序性能。
>
> 延迟初始化: 仅在必要时进行资源的初始化和分配。
>
> 局部性原理: 尽量优化数据的局部性访问，特别是在循环等操作中。
>
> RAII: 资源获取即初始化（RAII）是C++中一种常用的资源管理和异常安全的设计模式，可考虑其用于资源的自动管理。
>
> 使用现代C++特性: 比如auto关键字、范围基础的for循环等，它们不仅可以简化代码，还有助于编译器进行优化。



#### keyword assert

用于开发阶段的调试。

#### keyword noexcept

加上noexcept的函数将承诺不会抛出异常。如果真的存在异常，将会导致整个程序停止。主要是为了告诉编译器，使编译器进行优化，让编译器知道这里绝不会抛异常，不必多生成保护栈上对象安全析构的代码。

#### =default

#### using与typedef的区别

using支持模板别名，而typedef不可

```C++
template <typename T>
using Vec = std::vector<T>;
```

可读性更好，顺序更自然

```c++
using IntPtr = int*;
typedef int* IntPtr;
```

 嵌套类型时using更直观 

```c++
typedef void (*Func)(int, int);
using Func = void (*)(int, int);

// 函数表功能
typedef int (*OperationFuncPtr)(int, int);
int multiply(int a, int b) {
    return a * b;
}

OperationFuncPtr operations[] = {add, multiply};

int result1 = operations[0](3, 4);  // 3 + 4 = 7
int result2 = operations[1](3, 4);  // 3 * 4 = 12

// 回调
void execute(AddFuncPtr func, int a, int b) {
    int result = func(a, b);
    std::cout << "Result: " << result << std::endl;
}

// 成员函数指针
class MyClass {
public:
    void myMethod(int a) {
        std::cout << "Value: " << a << std::endl;
    }
};

using MethodPtr = void (MyClass::*)(int);

MyClass obj;
MethodPtr ptr = &MyClass::myMethod;
(obj.*ptr)(5);  // 输出 "Value: 5"


```

BTW: 关于函数名的理解：函数名本质上是一个指向函数地址的指针。正因为如此可以直接将函数名赋值给一个函数指针，如：void (*funcPtr)() = myFunction; funcPtr(); 当然，也可以通过对&myFunction明确的取地址。

Using可以用来引入基类的名称，从而实现函数重载，否则同名不同参的函数在子类中，基类函数会被隐藏，强行调用（如传入基类函数声明的参数类型，会报错）

```c++
class Base {
public:
  void someMethod(int a) {
  }
};


class Derived : public Base {
public:
	using Base::someMethod;
  void someMethod(double d){}
};
```



### ⭐Memory Pool

https://github.com/cacay/MemoryPool/tree/master

结构：

使用模板类，接受两个模板参数：元素类型T和块大小BlockSize

.h file:

```c++
#ifndef MEMORY_POOL_H
#define MEMORY_POOL_H

#include <climits>
#include <cstddef>

template <typename T, size_t BlockSize = 4096>
class MemoryPool
{
  public:
    /* Member types */
    typedef T               value_type;
    typedef T*              pointer;
    typedef T&              reference;
    typedef const T*        const_pointer;
    typedef const T&        const_reference;
    typedef size_t          size_type;
    typedef ptrdiff_t       difference_type;
    typedef std::false_type propagate_on_container_copy_assignment;
    typedef std::true_type  propagate_on_container_move_assignment;
    typedef std::true_type  propagate_on_container_swap;

    template <typename U> struct rebind {
      typedef MemoryPool<U> other;
    };

    /* Member functions */
    MemoryPool() noexcept;
    MemoryPool(const MemoryPool& memoryPool) noexcept;
    MemoryPool(MemoryPool&& memoryPool) noexcept;
    template <class U> MemoryPool(const MemoryPool<U>& memoryPool) noexcept;

    ~MemoryPool() noexcept;

    MemoryPool& operator=(const MemoryPool& memoryPool) = delete;
    MemoryPool& operator=(MemoryPool&& memoryPool) noexcept;

    pointer address(reference x) const noexcept;
    const_pointer address(const_reference x) const noexcept;

    // Can only allocate one object at a time. n and hint are ignored
    pointer allocate(size_type n = 1, const_pointer hint = 0);
    void deallocate(pointer p, size_type n = 1);

    size_type max_size() const noexcept;

    template <class U, class... Args> void construct(U* p, Args&&... args);
    template <class U> void destroy(U* p);

    template <class... Args> pointer newElement(Args&&... args);
    void deleteElement(pointer p);

  private:
    union Slot_ {
      value_type element;
      Slot_* next;
    };

    typedef char* data_pointer_;
    typedef Slot_ slot_type_;
    typedef Slot_* slot_pointer_;

    slot_pointer_ currentBlock_;
    slot_pointer_ currentSlot_;
    slot_pointer_ lastSlot_;
    slot_pointer_ freeSlots_;

    size_type padPointer(data_pointer_ p, size_type align) const noexcept;
    void allocateBlock();

    static_assert(BlockSize >= 2 * sizeof(slot_type_), "BlockSize too small.");
};

#include "MemoryPool.tcc"

#endif // MEMORY_POOL_H
```

#### 子类对父类构造函数的调用方式

```c++
// Method1: 构造函数初始化列表
class Base {
    public:
        Base(int a) {}
};

class Derived : public Base {
    public:
        Derived(int a) : Base(a) {}  // 调用父类的构造函数
};

// Method2：默认构造，即隐式地调用
class Base {
    public:
        Base() {}  // 默认构造函数
};

class Derived : public Base {
    public:
        Derived(int a) {}  // 隐式调用父类的默认构造函数
};

// Method3: using
// C++11引入了一个新特性，允许子类通过using声明继承父类的构造函数。这样，子类可以直接使用父类的构造函数，而不需要在子类中重新定义它们。
class Base {
    public:
        Base(int a) {}
        Base(int a, int b) {}
};

class Derived : public Base {
    public:
        using Base::Base;  // 继承父类的所有构造函数
};

```



# <mark>Effective C++</mark>

### 04 Make sure that objects are intialized before they're used



## Chapter 2: Construtors, Destructors, and Assignment Operators

### 05: Know what functions C++ silently writes and calls

如果开发者自己没有声明，编译器会自动声明：copy构造函数，default构造函数（当没有任何构造函数时），copy assignment操作符，析构函数。其中析构函数是non-virtual的，除非该类包含其他的virtual函数。所有这些函数都是public且inline的。

其中copy构造函数和copy assign操作符的默认功能是，将来源对象的每一个non-static成员变量拷贝到目标对象。

如果一个类的成员里包含reference成员，那么C++将拒绝为该类生成copy assignment操作符。第一是本身C++具有引用不可变性，引用的指向不可变，因此copy赋值过程中，该reference成员首先不会改指向实参对象中的那个reference成员。第二，那就只能是修改指向的值了，但这会进一步影响持有该成员的引用的其他对象，所以这个copy assign行为必须由开发者自己定义。

```c++
template<class T>
class NamedObject {
public:
    NamedObject(std::string& name, const T& value);
    ...
private:
    std::string& nameValue;
    const T objectValue;
};


std::string newDog("A");
std::string oldDog("B");
NamedObject<int> p(newDog, 2);
NamedObject<int> s(oldDog, 36);

p=s; // what would happen?
```

面对包含const成员的类，编译器也是一样，由于更改const成员是不合法的，因此编译器不知道如何处理赋值函数。

此外，如果基类将copy assignment操作符声明为private，则编译器将不会给子类生成copy assign操作符。因为原本子类的copy assignment操作符应该能够处理base class的成分。



### 06: Explicitly disallow the use of compiler-generated functions you do not want

明确拒绝我们不想使用的编译器自动生成的函数

不声明copy构造函数或copy assignment操作符，编译器可能会自动产出一份，于是class支持了copying。但是如果我们就是不希望class支持copying呢？

关键在于：编译器自动产出的函数都是public的，因此一个解决方案是令这些函数为private，从而阻止外部的调用。

这个方法不是绝对的安全，因为member函数和friend函数都可以调用private函数。

可以声明一个基类来专门负责：

```c++
class Uncopyable {
protected:
    Uncopyale() {};  // 允许子类对象构造和析构
    ~Uncopyable() {}; // 注意这里不一定得是virtual的，见条款07
private:
    Uncopyable(const Uncopyable&); // 阻止copy
    Uncopyable& operator=(const Uncopyable&);
}

class HomeForSale: private Uncopyable { // private使得基类的public和protected成员在子类中变为私有成员
    ... // class不需要再声明copy构造函数和copy赋值运算符为private
}
```

> 你认为uncopyable这个基类的析构函数不需要是virtual的原因有哪些？
>
> ChatGPT
>
> 在此情况下，`Uncopyable`基类的析构函数不需要是`virtual`的，主要有以下几个原因：
>
> 1. **非多态基类**： `Uncopyable`的目的是为了禁止复制和赋值，而不是为了提供多态行为。通常，只有当基类打算被用作多态基类时，析构函数才需要是`virtual`的。
> 2. **无需基类指针**： `Uncopyable`基类没有任何其他的成员函数，也不包含任何可重写的虚函数。因此，很少有情况需要通过指向`Uncopyable`的指针或引用来操作`HomeForSale`对象。无需通过基类指针删除派生类对象，所以不需要`virtual`析构函数。
> 3. **无资源管理**： `Uncopyable`基类不包含任何资源（如动态分配的内存），也没有定义任何实际的析构逻辑。因此，即使析构函数不是`virtual`的，也不会出现资源泄露的问题。
> 4. **减少虚表开销**： 为基类定义`virtual`析构函数会为该类添加一个虚表（vtable）。虚表是一个存储类的虚函数地址的表，它会增加每个对象的大小，并可能稍微降低性能。在这种情况下，由于`Uncopyable`的目的是为了提供禁止复制和赋值的能力，而不是为了提供多态行为，所以没有必要为它增加虚表的开销。
>
> 综上所述，`Uncopyable`基类的析构函数不需要是`virtual`的，因为它不是为了提供多态行为，而是为了禁止复制和赋值。

BTW，about private继承所带来的：子类继承了基类的实现，但并不继承基类的接口，如何理解？<mark>子类内部可访问基类成员，但子类对象不能调用。</mark>

```c++
class Base {
public:
    void baseFunction() {
        std::cout << "Base function called" << std::endl;
    }
};

class Derived : private Base {
public:
    void derivedFunction() {
        baseFunction();  // 正确：在Derived内部可以访问Base的成员
    }
};

int main() {
    Derived d;
    d.derivedFunction();  // 输出：Base function called
    // d.baseFunction();  // 错误：baseFunction在Derived中是私有的
    return 0;
}
```

如果一定想调用呢？通过创建一个新方法，或使用using声明：

```c++
class Base {
public:
    void baseFunction() {
        std::cout << "Base function called" << std::endl;
    }
};

class Derived : private Base {
public:
    using Base::baseFunction;  // 使用 using 声明使 baseFunction 在 Derived 类中可访问

    void derivedFunction() {
        baseFunction();  // 现在这是正确的
    }
};

int main() {
    Derived d;
    d.derivedFunction();  // 输出：Base function called
    d.baseFunction();  // 现在这也是正确的
    return 0;
}
```





### 07: Declare destructors virtual in polymorphic base classes

polymorphic base classes should declare a virtual destructor. 并且如果class中带有任何virtual函数，那么它就应该拥有一个virtual析构函数；

classes的设计目的如果不是作为base classes使用，或不是为了多态，就不该声明virtual函数

比如有一个记录时间的基类TimeKeeper，可能会有多种子类，AtomicClock，WaterClock，WristClock。并设计了一个工厂函数提供一个计时对象，工厂函数会返回一个base class指针，指向derived class对象。

```c++
class TimeKeeper() {
public:
    TimeKeeper();
    ~TimeKeeper(); // non-virtual
};

class AtomicClock: public TimeKeeper {...};
class WaterClock: public TimeKeeper {...};
class WristClock: public TimeKeeper {...};

TimeKeeper* getTimeKeeper();

// 为了遵守factory函数的规矩，被该函数返回的对象必须是在堆区。为了避免内存泄漏，需要delete
...
delete ptk;


```

条款13认为依赖于客户执行delete动作，本身就具有某种错误倾向；

此处更严重的问题是，工厂函数返回的指针指向一个derived class对象比如AtomicClock对象，但是对象却经由一个base class指针比如TimeKeeper* 来删除，而当前基类的析构函数是non-virtual的。会导致：<mark>对象的derived成分没被销毁，子类的析构函数也未能被运行，导致诡异的局部销毁，从而造成资源泄露</mark>。因此修改：

```c++
class TimeKeeper() {
public:
    TimeKeeper();
    virtual ~TimeKeeper(); //virtual
};
```

此外，像TimeKeeper这样的基类一般还会有除了析构函数以外的其他virtual函数，比如`virtual getCurrentTime`，在不同的子类中应该有不同的实现。再次强调：任何class只要带有virtual函数几乎确定也应该有一个virtual destructor。如果不打算将其作为base class，一般不需要使用virtual。

<u>即使class完全没有virtual函数，non-virtual析构函数有时候也会带来问题</u>：比如继承标准库的一些类如string，其析构函数是non-virtual的。

```c++
class SpecialString: puhblic std::string { // Really awful! }
```

假如程序无意中将一个pointer-to-SpecialString转换为pointer-to-string，并将转换所得的指针delete掉，就会导致行为不明确。

```c++
SpecialString* pss = new SpecialString("Impending Doom");
std::string* ps;
...
ps = pss; // 向上转型
...
delete ps; // 未定义！SpecialString的析构函数没有被调用
```

C++并没有像java一样的final关键字来禁止派生

<mark>关于pure virtual析构函数，必须为其提供定义</mark>。这个会在一些场景下提供一些便利，但是pure virtual会导致类变成抽象基类，无法实例化。析构函数的运作顺序：从most derived的类开始被调用，然后依次到最顶上的base class的析构函数。因此，编译器会在AWOV的derived classes的析构函数中创建一个对~AWOV的调用动作，因此必须提供一个定义。否则导致链接错误。

```c++
class AWOV {
public:
    virtual ~AWOV() = 0;  // 纯虚析构函数
};

AWOV::~AWOV() {}  // 纯虚析构函数的定义
```



## 4 Designs and Declarations 设计与声明

### 18: Make interfaces easy to use correctly and hard to use incorrectly

开发一个接口，首先需要考虑client可能做出什么样的错误。

诸如：

```c++
class Date{
public:
    Date(int month, int day, int year);
};

Date(3,30,1995); // True
Date(30,3,1995); // False
```

针对这种不值得拥有的代码的问题上，我们需要Type System来协助。导入简单的wrapper types来区分天数、月份和年份：

```c++
#include <iostream>
#include <iomanip>

struct Day
{
    explicit Day(int d) : val(d)
    {
    }

    int val;
};

struct Month
{
    explicit Month(int m) : val(m)
    {
    }

    int val;
};

struct Year
{
    explicit Year(int y) : val(y)
    {
    }

    int val;
};

class Date
{
private:
    Month month;
    Day day;
    Year year;

public:
    Date(const Month &m, const Day &d, const Year &y) : month(m), day(d), year(y){};
	
    // 一般重载运算符作为类的非成员变量通过friend关键字来获取访问类的私有成员的权限
    friend std::ostream &operator<<(std::ostream& os, const Date &date);
};

std::ostream &operator<<(std::ostream& os, const Date &date)
{
    // 如果date.month这里不加.month是不行的，除非struct Month内部声明了Month是如何<<的
    os << std::setw(2) << std::setfill('0') << date.month << '/'
       << std::setw(2) << std::setfill('0') << date.day.val << '/'
       << date.year.val;

    return os;
}

int main(){
    Date d(30, 3, 1995); // Wrong
	Date d(Day(30), Month(3), Year(1995)); // Wrong
    Date d(Month(3), Day(30), Year(1995)); // Right
}

```

此时，类型安全了，但是还需要限制其值，比如月份不能有13月：

```c++
class Month {
public:
    static Month Jan(){
        return Month(1);
    };
    ...

    friend std::ostream& operator<<(std::ostream& os, const Month &month);
    
private:
    // 也就是说不允许手动构造Month对象，而要通过类的静态方法来构造。
    explicit Month (int m):month(m){};
    int month;
};

std::ostream& operator<<(std::ostream& os, const Month &month){
    os<< month.month;
    return os;
}

int main(){
     Date d(Month::Jan(), Day(5), Year(1995));
}
```

任何接口如果要求客户必须记得做哪些事情，就有着不正确使用的倾向，因为客户可能会忘记。比如Rule 13的factory函数返回一个指向Investment继承体系内的动态分配对象：

```c++
Investment* createInvestment();
```

为避免资源泄露，该指针最终必须被删除，这一逻辑导致了潜在的两个问题：

1）client忘记delete 2）delete了两次

因此，rule 13的做法是将返回值存储于一个智能指针内，auto_ptr or tr1::shared_ptr。

又有了新问题：如果client忘记将指针包装成智能指针？优秀的做法是：先发制人，令该工厂函数直接返回一个智能指针：

```c++
std::tr1::shared_ptr(Investment) createInvestment();
```

shared_ptr允许智能指针创建时，我们指定一个自定义的资源释放函数，deleter删除器。auto_ptr是不行的。如：

```c++
std::tr1::shared_ptr<Investment> createInvestment(){
	std::tr1::shared_ptr<Investment> retVal(
        // 想创建一个null shared_ptr，而0是一个int，虽然其可以被转换为指针 但为shared_ptr的构造器要求第一参数是一个真正的指针
        static_cast<Investment* >(0), getRidOfInvestment);
    retVal = ...;
    return retVal;
}
   
```

注：如果业务逻辑上原始指针能够先于智能指针创建，直接将原始指针交给智能指针要比先把智能指针初始化再赋值要好，原因见rule 26。

还有一个优势是 解决了cross-dll problem 不懂。可被用来解除互斥锁 见rule 14

但是智能指针往往开销要高于原始指针，如：

1）更大的内存开销：引用计数和自定义删除器

2）运行时开销：拷贝和赋值发生时，引用计数更新



### 19：Treat class design as type design

设计class犹如设计type，需要考虑的问题：

- 新type的对象如何被创建和销毁？构造器、析构函数、内存分配函数、释放函数(operator new, operator new[], operator delete, operator delete[])

- 对象的初始化和赋值应该有什么差别？初始化和赋值的区别？Rule 4

- 如果对象以值传递意味着什么？copy构造函数用来定义pass by value如何实现

- 什么是新type的合法值？约束是什么，错误检查，异常抛出

- 需要配合某个继承图系吗inheritance graph。如是，则将受到既有class设计的束缚，特别是virtual和non-virtua的问题（Rule34&36）

- 新type需要什么样的转换？是否允许T1类型被隐式转换为T2，则T1内部需要operator T2。如果只允许explicit构造函数存在，则得写出专门负责执行的函数，且不得为type conversion operators 或 non-explicit-one-argument构造函数。（见rule 15的隐式和显示转换示例）

  ```c++
  // type conversion operators
  class T1 {
  public:
      operator T2() const {
          // ...转换逻辑...
          return T2_converted_value;
      }
  };
  
  class T2 {
      // ...
  };
  
  int main() {
      T1 obj1;
      T2 obj2 = obj1;  // 隐式转换
  }
  
  
  // non-explicit-one-argument constructor
  // 注意，单参构造函数与copy构造函数很像，但有区别。单参重在从另一类型对象创建本类的新对象，进行类型转换操作。而copy构造函数是从同类的另一对象创建新对象。
  class T2 {
  public:
      T2(const T1& obj) {
          // ...转换逻辑...
      }
      // ...
  };
  
  int main() {
      T1 obj1;
      T2 obj2 = obj1;  // 隐式转换
  }
  
  // explicit显式转换，不允许隐式转换
  class T2 {
  public:
      explicit T2(const T1& obj) {
          // ...转换逻辑...
      }
      // ...
  };
  
  int main() {
      T1 obj1;
      T2 obj2 = obj1;  // 错误：不允许隐式转换
      T2 obj3(obj1);   // 正确：显式转换
  }
  
  ```

- 什么样的操作符和函数是合理的？（Rule 23，24，46）

- 什么样的标准函数应该驳回？private ，Rule 6

- 谁该取用新type的成员？成员public、protected or private？哪个类和函数应该是friend？

- 什么是新type的undeclared interface?对效率、异常安全（Rule29）和资源运用如多任务锁定和动态内存有何保证？

- 该type有多一般化？究竟是一个独特的class，还是一个class家族，是否需要使用class template

- 是否真的需要一个新type？是否能通过继承添加新功能就能满足需求？



### 20 Prefer pass-by-reference-to-const to pass-by value

以const引用传递替代值传递

缺省情况下C++以by value方式传递对象至函数。即：函数参数是以实参的副本为初值，而调用端获得的也是函数返回值的一个副本。

假如Person类具有两个String成员，Student类继承自Person类。student对象以值传递方式给函数validteStudent。总共的操作：copy构造student，copy构造student内部的两个string，copy构造person对象，copy构造person内部的两个string。再同样地进行析构。6次构造6次析构。

同时，引用传递还可以避免slicing对象切割的问题。

对象切割：

> 在C++中，当你将一个对象以值传递给一个函数时，会发生对象的切割（object slicing）。对象切割是指只有基类部分的数据被复制和传递给函数，而派生类特有的数据则被切割掉。这是因为目标类型（在本例中是基类）只有足够的空间来存储基类的数据，没有额外的空间来存储派生类特有的数据。

```c++
#include <iostream>

class Base {
public:
    virtual void A() const {
        std::cout << "Base::A" << std::endl;
    }
};

class Derived : public Base {
public:
    void A() const override {
        std::cout << "Derived::A" << std::endl;
    }
};

void callA(Base obj) {
    obj.A();
}

int main() {
    Derived d;
    callA(d);  // Output: Base::A
    return 0;
}
```

> 在这个例子中，函数`callA`接受一个`Base`类型的对象作为参数。当我们尝试将一个`Derived`对象传递给`callA`时，`Derived`对象被切割为`Base`对象，只有基类部分的数据被传递给`callA`函数。因此，当在`callA`函数中调用`A`方法时，`Base`类版本的`A`方法被调用，而不是`Derived`类版本的`A`方法。
>
> 为了避免对象切割并保留多态行为，你应该使用指针或引用传递对象，而不是值传递。
>
> 
>
> **如果callA的形参是引用传递，但是基类A函数没加virtual，会发生什么**
>
> 如果`callA`的形参是通过引用传递，但基类的`A`函数没有被声明为`virtual`，那么将发生静态绑定（static binding），而不是动态绑定（dynamic binding）。这意味着在编译时会确定要调用的函数版本，而不是在运行时。
>
> 在这种情况下，即使你传递一个派生类对象给`callA`函数，也会调用基类版本的`A`函数，而不是派生类版本的`A`函数。下面是一个例子来说明这种情况：

```c++
#include <iostream>

class Base {
public:
    void A() const {  // 注意: 这里没有使用 virtual 关键字
        std::cout << "Base::A" << std::endl;
    }
};

class Derived : public Base {
public:
    void A() const {
        std::cout << "Derived::A" << std::endl;
    }
};

void callA(Base& obj) {  // 使用引用传递
    obj.A();
}

int main() {
    Derived d;
    callA(d);  // Output: Base::A
    return 0;
}
```



但对于，内置类型、STL迭代器和函数对象，pass-by-value可以接受。