---
layout:     post
title:      "Notes - C++ Learning | C++学习笔记"
subtitle:   " \"C++ Primer Plus / Effective C++ / Numerical Methods / My Notes...\""
date:       2023-09-09 12:00:00
author:     "Yibo Li"
header-img: "img/post-bg-2015.jpg"
multilingual: false
catalog: true
tags:
    - C++
    - Quant
    - Notes
---

> “Within C++, there is a much smaller and cleaner language struggling to get out.”


# Notes - C++ Learning | C++学习笔记

2023-05-08

Yibo Li

yli12@stevens.edu; yiboli@link.cuhk.edu.hk

http://eborlee.github.io

## Table Of Contents


* TOC
{:toc}


# Book: Numerical Methods in Finance with C++

## 1 Basic Usages

- It is a best practice to almost always set your destructors to be virtual.
- const double getK() and double getK() const: 后者为常量成员函数，无法修改对象的任何成员变量，除非该变量被声明为mutable。





## 1 Binomial Pricer

#### Ways of passing parameters:

1. Passed By Value: double S(double S0, double U, ...)

   When a function is called, a copy of that variable is made in a separate location in computer memory. The func could see and change the copy, but has no access to the original varible. And the calling program could also see the copy and only has access to the original variable.

2. Passed By Reference: int GetInputData(double& S0, ...)

   C++ can return only a single value in a function and this way enables to pass all the inputs back to the program.

   In this case, a single copy of the variable in computer memory is shared by the function and the calling program.

   

---

#### Separate Compilation

After defining some function protoptypes in .h file: changes to one of the .cpp files do not require the other file to be recompiled as long as the function prototypes remain unchanged. In large projects this can mean considerable savings in compilation time.

## 2 Binomial Pricer Revisited



## 3 American Options

### 3.1 Multiple Inheritance

***<u>菱形继承问题的解决方案：</u>***

- 1.Virtual Inheritance
- 2.作用域解析运算符
- 3.重新定义函数

```c++
#include <iostream>
using namespace std;

class A
{
public:
    void func(){
        cout<<"This is A"<<endl;
    };
};

class B: virtual public A{
    public:
    void func() {
        cout<<"This is B"<<endl;
    };

};
class C: virtual public A{
    public:
    void func() {
        cout<<"This is C"<<endl;
    };
};

class D: public B, public C{
    public:
    void func() {
        cout<<"This is D"<<endl;
    }
};

class E: public B, public C{
    // E不给实现，就会导致二义性，编译器不知道该找哪个方法
};

class F: public B, public C{
    public:
    void func(){
        C::func();
    }
};

int main(){
    
    D d;
    E e;
    d.func();
    // e.func(); // 二义性，无法编译 对比python，python是运行时报错，基于MRO。

    // 方法2 作用域解析运算符
    e.B::func();

    // 方法3 重新定义函数
    F f;
    f.func();
    
}
```

题外话，对比python，python对于菱形继承，D继承自BC，而D没有给方法实现，第一python的多重继承和方法解析是在运行时进行，而不是在编译时。第二，python的MRO(Method Resolution Order)算法会根据MRO顺序来决定使用哪个方法，除非明确调用不存在的方法和属性。

```python
class A:
  def func(self):
    print("A")

class B(A):
  def func(self):
    print("B")
class C(A):
  def func(self):
    print("C")
    
class D(B,C):
	pass

d = D()
d.func() # 输出B

print(D.mro())

```



3.2 Virtual Inheritance

3.3 Class Templates

## 4 Non-linear Solvers

**Basic Knowledge:**

BSM Formula:
$$
C(S_0, K, T,\sigma,r)=S_0N(d_+)-Ke^{-rT}N(d_-)\\
d_+=\frac{ln(\frac{S_0}{K})+(r+\frac{\sigma^2}{2})T}{\sigma\sqrt{T}}\\
d_-=d_+-\sigma\sqrt{T}\\
N(x)=\int_{-\infty}^x \frac{1}{\sqrt{2\pi}}e^{-\frac{y^2}{2}}dy
$$
If the values of S0, K, T, σ,r are all known, then we can calculate the price of option. Among these items, only σ is not known and needed to be estimated using the market option price.

There are two common methods for this purpose: Bisection method and Newton-Raphson method.



**Bisection Method:**

We want to compute a solution x to an equation: f(x) = c, where f is a given function from an interval [a,b] to R. It is assumed that f is continuous on [a,b] and f(a)-c, f(b)-c have opposite signs. Then there must be an x∈[a,b] such that f(x)=c.

The bisection method works by constructing sequences l, r of left and right approximations by induction:

(l+r)/2 -> mid, f(mid)-c

If f(l) * f(mid) > 0, root lies in [mid, r], mid -> l;

If f(l) * f(mid) <0, root lies in [l, mid], mid ->r;

If f(mid) == 0, mid is the root, Stop.

And if |mid - l | <=  Accuracy requirement, stop. Input the mid and the corresponding f(mid)-c at that moment.


**Newton-Raphson Method:**

f is assumed to be differentiable on [a,b] and construct a sequence xn as follows:
$$
Take ~x0∈(a,b).\\
For~ n=0,1,2,..., let\\
x_{n+1}=x_n-\frac{f(x_n)-c}{f'(x_n)}
$$
If the equation f(x)=c has a solution x∈(a,b) such that f'(x)≠0 and x0 is chosen close enough to x, then xn will converge to x.

### 4.1 使用Function Pointer的基本实现

```c++
#ifndef Solver01_h
#define Solver01_h

double SolveByBisect(double (*Fct)(double x), double Tgt,
                     double LEnd, double REnd, double acc)
{
    double left = LEnd, right = REnd, mid = (left + right) / 2;
    double y_left = Fct(left) - Tgt, y_mid = Fct(mid) - Tgt;
    while (mid - left > acc)
    {
        if ((y_left > 0 && y_mid > 0) || (y_left < 0 && y_mid < 0))
        {
            left = mid;
            y_left = y_mid;
        }
        else
            right = mid;
        mid = (left + right) / 2;
        y_mid = Fct(mid) - Tgt;
    }
    return mid;
}

// Newton-Raphson Method
double SolveByNR(double (*Fct)(double x), double (*DFct)(double x), double Tgt,
                 double guess, double acc)
{
    double x_prev = guess;
    double x_next = x_prev - (Fct(x_prev) - Tgt) / DFct(x_prev);
    while (x_next - x_prev > acc || x_prev - x_next > acc)
    {
        x_prev = x_next;
        x_next = x_prev - (Fct(x_prev) - Tgt) / DFct(x_prev);
    }
    return x_next;
}

#endif
```

```c++
#include "Solver01.h"
#include <iostream>
using namespace std;

double F1(double x){return x*x-2;}
double DF1(double x){return 2*x;}

int main(){
    double Acc = 0.001;
    double LEnd=0.0, REnd=2.0;
    double Tgt = 0.0;
    cout << "Root of F1 by bisect:"
         << SolveByBisect(F1, Tgt, LEnd, REnd, Acc)
         <<endl;
    double Guess = 1.0;
    cout << "Root of F1 by newton-raphson:"
         << SolveByNR(F1, DF1, Tgt, Guess, Acc)
         <<endl;

    return 0;
}
```

这种方式简单却不易于expansion。如果传入的Function形如f(x)没问题，但是f(x,a) = x^2-a不适用。

### 4.2 **使用Virtual Functions**: Enable dynamic binding

Dynamic Binding :动态联编是指在运行时根据实际对象的类型来确定要调用的函数实现，而不仅仅根据指针或引用的静态类型。这意味着，当通过基类的指针或引用调用虚函数时，实际调用的是对象的派生类中所重写的虚函数。这种动态绑定机制使得在继承体系中可以实现多态性，允许通过基类的接口来操作具体的派生类对象，而不需要显式指定对象的具体类型。

而如果在签名中声明为类对象本身而不是其指针，就会导致： <mark>虽然可以传入其子类，但是调用方法还是调用的同一个父类方法，而不会调用子类重写的方法。</mark>

```c++
#include <iostream>

class Animal {
public:
    virtual void MakeSound() {
        std::cout << "Animal is making a sound" << std::endl;
    }
};

class Dog : public Animal {
public:
    void MakeSound() override {
        std::cout << "Dog is barking" << std::endl;
    }
};

class Cat : public Animal {
public:
    void MakeSound() override {
        std::cout << "Cat is meowing" << std::endl;
    }
};

void PerformSound(Animal* animal) {
    animal->MakeSound();
}

void PerformSound2(Animal animal) {
    animal.MakeSound();
}

int main() {
    Animal animal;
    Dog dog;
    Cat cat;
    // 当使用基类指针作为参数时，可以实现运行时的多态性，使代码能够根据实际传递的派生类对象来选择相应的函数实现。
    // dynamic binding
    PerformSound(&animal); // Output: "Animal is making a sound"
    PerformSound(&dog);    // Output: "Dog is barking"
    PerformSound(&cat);    // Output: "Cat is meowing"

    // 如果直接传递基类对象本身，编译器在编译时就确定了要调用的函数实现，无法在运行时动态选择不同的函数实现。
    PerformSound2(animal); // Output: "Animal is making a sound"
    PerformSound2(dog);    // Output: "Animal is making a sound"
    PerformSound2(cat);    // Output: "Animal is making a sound"
    return 0;
}

```

继续Solver的例子：

```c++
#ifndef Solver02_h
#define Solver02_h

class Function
{
public:
    virtual double Value(double x) = 0;
    virtual double Deriv(double x) = 0;
};

double SolveByBisect(Function *Fct, double Tgt, double LEnd, double REnd, double Acc)
{
    double left = LEnd, right = REnd, mid = (left + right) / 2;
    double y_left = Fct->Value(left) - Tgt, y_mid = Fct->Value(mid) - Tgt;
    while (mid - left > Acc)
    {
        if ((y_left > 0 && y_mid > 0) || (y_left < 0 && y_mid < 0))
        {
            left = mid;
            y_left = y_mid;
        }
        else
            right = mid;
        mid = (left + right) / 2;
        y_mid = Fct->Value(mid) - Tgt;
    }
    return mid;
}

double SolveByNR(Function *Fct, double Tgt, double guess, double acc)
{
    double x_prev = guess;
    double x_next = x_prev - (Fct->Value(x_prev) - Tgt) / Fct->Deriv(x_prev);
    while (x_next - x_prev > acc || x_prev - x_next > acc)
    {
        x_prev = x_next;
        x_next = x_prev - (Fct->Value(x_prev) - Tgt) / Fct->Deriv(x_prev);
    }
    return x_next;
}

#endif
```

```c++
#include "Solver02.h"
#include <iostream>
using namespace std;

class F1 : public Function
{
public:
     double Value(double x) { return x * x - 2; }
     double Deriv(double x) { return 2 * x; }
} MyF1;

class F2 : public Function
{
private:
     double a;

public:
     F2(double a_)
     {
          a = a_;
     }
     double Value(double x) { return x * x - a; }
     double Deriv(double x) { return 2 * x; }
} MyF2(3.0);

int main()
{
     double Acc = 0.001;
     double LEnd = 0.0, REnd = 2.0;
     double Tgt = 0.0;
     cout << "Root of F1 by bisect:"
          << SolveByBisect(&MyF1, Tgt, LEnd, REnd, Acc)
          << endl;
     double Guess = 1.0;
     cout << "Root of F2 by newton-raphson:"
          << SolveByNR(&MyF2, Tgt, Guess, Acc)
          << endl;

     return 0;
}
```

使用虚函数在运行时进行动态绑定是有一些开销的，这是因为动态绑定需要在运行时查找正确的函数实现。这些开销包括：

1. 虚函数表（vtable）：为了实现动态绑定，编译器会为每个包含虚函数的类生成一个虚函数表。虚函数表是一个指针数组，用于存储每个虚函数的地址。对于每个类对象，都会包含一个指向其虚函数表的指针。这样，当调用虚函数时，需要通过指针查找正确的函数地址。
2. 虚函数调用开销：调用虚函数时，需要通过指针间接调用函数。这涉及额外的间接跳转操作，相对于直接调用非虚函数，会增加一定的开销。

总体来说可以忽略不计，但是以下情景需要注意：

1. <u>循环中使用虚函数会造成大量开销</u>
2. 使用虚函数的地方可以进行性能优化，例如使用内联（inline）修饰符来尝试避免间接跳转的开销。
3. 考虑使用其他的技术，如模板和策略模式，来避免使用虚函数带来的开销。

### 4.3 使用Templates模板

**极大的保留了虚函数的优点，但是将type checking从runtime转移到了compile time.**

代码与虚函数大体相似，但简化了：不需要定义抽象基类和其虚函数，具体的公式类也不需要再继承共同的父类。

缺点：如果有大量的函数将会带来较长的编译时间和较大的.exe文件。

```c++
#ifndef Solver03_h
#define Solver03_h

template <typename Function>
double SolveByBisect(Function *Fct, double Tgt, double LEnd, double REnd, double Acc)
{
    double left = LEnd, right = REnd, mid = (left + right) / 2;
    double y_left = Fct->Value(left) - Tgt, y_mid = Fct->Value(mid) - Tgt;
    while (mid - left > Acc)
    {
        if ((y_left > 0 && y_mid > 0) || (y_left < 0 && y_mid < 0))
        {
            left = mid;
            y_left = y_mid;
        }
        else
            right = mid;
        mid = (left + right) / 2;
        y_mid = Fct->Value(mid) - Tgt;
    }
    return mid;
}

template <typename Function>
double SolveByNR(Function *Fct, double Tgt, double guess, double acc)
{
    double x_prev = guess;
    double x_next = x_prev - (Fct->Value(x_prev) - Tgt) / Fct->Deriv(x_prev);
    while (x_next - x_prev > acc || x_prev - x_next > acc)
    {
        x_prev = x_next;
        x_next = x_prev - (Fct->Value(x_prev) - Tgt) / Fct->Deriv(x_prev);
    }
    return x_next;
}

#endif
```

此时这两个solver函数都是模板函数，即可以接收任意类型的Fct，编译器会在将来这个函数被调用时，根据调用的那句话中声明的typename的类型，来生成不同版本的函数，这样就避免了运行时开销。比如template<typename T> void print(T value){...}, 将来调用的时候，print<int>(42); print<double> (42.0); 就会生成不同版本的函数。

编译器针对已知的类型，更好的进行优化；编译器更容易进行内联优化；没有虚函数的运行时开销；生成更好的分支预测代码。 

```c++
#include "Solver03.h"
#include <iostream>
using namespace std;

class F1
{
public:
     double Value(double x) { return x * x - 2; }
     double Deriv(double x) { return 2 * x; }
} MyF1;

class F2
{
private:
     double a;

public:
     F2(double a_)
     {
          a = a_;
     }
     double Value(double x) { return x * x - a; }
     double Deriv(double x) { return 2 * x; }
} MyF2(3.0);

int main()
{
     double Acc = 0.001;
     double LEnd = 0.0, REnd = 2.0;
     double Tgt = 0.0;
     cout << "Root of F1 by bisect:"
          << SolveByBisect(&MyF1, Tgt, LEnd, REnd, Acc)
          << endl;
     double Guess = 1.0;
     cout << "Root of F2 by newton-raphson:"
          << SolveByNR(&MyF2, Tgt, Guess, Acc)
          << endl;

     return 0;
}
```



同时，由于不再使用虚函数，SolveByBisect和SolveByNR的声明也不需要再使用Fct指针，使用Fct就可以了。



### 4.4 Computing Implied Volatility

Define EurCall.h for computing the call option price using BSM using solver03.h, i.e. Templates version.

To compute it using Newton-Raphson method, we also need an expression for the derivative of the European call option price with respect to volatility σ calculated from BSM formula, **Vega**, is given by:
$$
v=\frac{1}{\sqrt{2\pi}}S_0e^{\frac{-d_+^2}{2}}
$$


```c++
#ifndef EurCall_h
#define EurCall_h

class EurCall
{
public:
    double T, K;
    EurCall(double T_, double K_) { T = T_, K = K_; }

    double d_plus(double S0, double sigma, double r);
    double d_minus(double S0, double sigma, double r);
    double PriceByBSFormula(double S0, double sigma, double r);

    double VegaByBSFormula(double S0, double sigma, double r);
};

#endif
```

Implement the methods in EurCall.cpp:

```c++
#include "EurCall.h"
#include <cmath>
#include <iostream>
using namespace std;
double N(double x)
{
    double result;

    if (x > 0)
    {
        result = 0.5 * (1.0 + erf(x / std::sqrt(2.0)));
    }
    else if (x == 0)
    {
        result = 0.5;
    }
    else
    {
        result = 0.5 * (1.0 - erf(-x / std::sqrt(2.0)));
    }

    return result;
}

double EurCall::d_plus(double S0, double sigma, double r)
{
    return (log(S0 / K) + (r + 0.5 * pow(sigma, 2.0)) * T) / (sigma * sqrt(T));
}

double EurCall::d_minus(double S0, double sigma, double r)
{
    return d_plus(S0, sigma, r) - sigma * sqrt(T);
}

double EurCall::PriceByBSFormula(double S0, double sigma, double r)
{
    return S0 * N(d_plus(S0, sigma, r)) - K * exp(-r * T) * N(d_minus(S0, sigma, r));
}

double EurCall::VegaByBSFormula(double S0, double sigma, double r)
{
    double pi = 4.0 * atan(1.0);
    return S0 * exp(-d_minus(S0, sigma, r) * d_plus(S0, sigma, r) / 2) * sqrt(T) / sqrt(2.0 * pi);
}
```

Run the functions in main_for_cal_imp.cpp. Here create a class as a intermediary class to translate the functions from EurCall to Solvers.

```c++
#include "Solver03.h"
#include "EurCall.h"
#include "EurCall.cpp"
#include <iostream>
using namespace std;

// 需要一个中间类进行初始化和翻译函数名
class Intermediary : public EurCall
{
private:
    double S0, r;

public:
    Intermediary(double S0_, double r_, double T_, double K_) : EurCall(T_, K_)
    {
        S0 = S0_;
        r = r_;
    }

    double Value(double sigma)
    {
        return PriceByBSFormula(S0, sigma, r);
    }

    double Deriv(double sigma)
    {
        return VegaByBSFormula(S0, sigma, r);
    }
};

int main()
{
    double S0 = 100.0;
    double r = 0.1;
    double T = 1.0;
    double K = 100.0;
    Intermediary Call(S0, r, T, K);

    double Acc = 0.001;
    double LEnd = 0.01, REnd = 1.0;
    double Tgt = 12.56;

    cout << "Root of F1 by bisect:"
         << SolveByBisect(&Call, Tgt, LEnd, REnd, Acc)
         << endl;
    double Guess = 0.23;
    cout << "Root of F2 by newton-raphson:"
         << SolveByNR(&Call, Tgt, Guess, Acc)
         << endl;

    return 0;
}
```



## 5 Monte Carlo methods

### LU Decomposition



```c++
#include <iostream>
#include <Eigen/Dense>
#include <Eigen/LU>
using namespace std;
using namespace Eigen;

int main(){
    typedef Matrix<double, 4,4> Matrix4x4;

    Matrix4x4 p;

    p<< 7,3,-1,2,
        3,8,1,-4,
        -1,1,4,-1,
        2,-4,-1,6;

    cout<< "Mat_P:\n"<<p<<endl<<endl;


    PartialPivLU<Matrix4x4> lu(p); // 此处在栈区创建了一个PPL对象，其构造函数自动对传入矩阵进行LU分解

    cout<< "Lu_Mat:\n"<<lu.matrixLU()<< endl<<endl;

    // 由于lu分解的下三角矩阵的主对角线都是1，所以需要先初始化一个单位矩阵
    // 使用到了静态函数
    Matrix4x4 l = MatrixXd::Identity(4,4);
    // 先获取一个从0，0开始的4*4的子矩阵再限定其视图为下三角，接受赋值
    l.block<4,4>(0,0).triangularView<StrictlyLower>() = lu.matrixLU();
    cout<<"L_mat:\n"<<l<<endl<<endl;

    // 由于上三角矩阵的主对角线是0，所以直接接受赋值
    Matrix4x4 u = lu.matrixLU().triangularView<Upper>();
    cout<<"u_mat:\n"<<u<<endl<<endl;
```





# C++ Primer Plus

## Chapter 4. 复合类型

### 4.8 指针、数组和指针算术

- 指针变量+1后，增加量等于其指向类型的字节数。
- C++将数组名解释为第一个元素的地址, 被解释为这个元素的指针。但本身是一个标识符，不是真正的指针
- *(stacks + 1)  <==> stacks[1]
- 对数组使用sizeof得到整个数组的长度，而对指针应用sizeof得到的是指针的字节长度，即使指针指向一个数组。
- 数组名：首个元素的地址， &数组名：整个数组的地址。数字上这两个地址相同，但是数组名是一个元素字节长度内存块的地址，而&数组名是一个数组整个长度字节内存块的地址。

```c++
// C++将数组名解释为数组第一个元素的地址
// wages = &wages[0] = address of first element of array
double wages[3] = {10.0, 20.0, 30.0};
short stacks[3] = {3, 2, 1};
double * pw = wages;
short * ps = &stacks[0];

cout << "pw=" << pw << ", *pw=" << *pw << endl;

pw = pw + 1;
cout << "pw=" << pw << ", *pw=" << *pw << endl;
cout << "ps=" << ps << ", *ps=" << *ps << endl;
cout << "stacks[0]=" << stacks[0] << ", stacks[1]=" << stacks[1] << endl;

cout << "*stacks=" << *stacks << ", *(stacks+1)=" << *(stacks+1) << endl;

cout<<sizeof(wages)<<endl;
cout<<sizeof(pw)<<endl;

// 数组名：首个元素的地址， &数组名：整个数组的地址
cout<<stacks<< ", "<<&stacks<<endl;
```

```c++
// output
pw=0x7ff7b61391f0, *pw=10
pw=0x7ff7b61391f8, *pw=20
ps=0x7ff7b61391e2, *ps=3
stacks[0]=3, stacks[1]=2
*stacks=3, *(stacks+1)=2
24
8
 0x7ff7bb3e61e2, 0x7ff7bb3e61e2
```



```c++
short tell[10];
short (*pas)[10] = &tell;
//(*pas)[i] 的意思是“解引用指针 pas 得到一个数组，然后访问该数组的第 i 个元素”
cout<<pas<<endl; // 指针指向的地址
cout<<pas[0]<<endl; // 也是首元素的地址
cout<<pas[1]<<endl; // 跳过1个数组，但指向了未定义的内存地址
cout<<*pas<<endl; // 解引用，数组的首元素的地址
cout<<(*pas)[0]<<endl; // 解引用之后获取第一个元素的值
cout<<*(*pas)<<endl; // 第一次解引用获取一个数组的指针，对数组指针再次解引用

//output
>>> 
0x7ff7b0bb61d0
0x7ff7b0bb61d0
0x7ff7b0bb61e4
0x7ff7b0bb61d0
-28656
-28656
```

在这个特定的情境下，`pas` 是一个指向长度为10的 `short` 数组的指针。对于 `pas[1]` 的解释在于，编译器认为你想跳过第一个长度为10的 `short` 数组，然后到达第二个这样的数组。当然，在这个特定的例子中，第二个这样的数组并不存在，所以 `pas[1]` 会指向一个未定义的内存区域。

通常，`pointer_to_array[n]` 的意义是“跳过 `n` 个数组，到达第 `n+1` 个数组的起始地址”，这里的数组是 `pointer_to_array` 指针所指向的类型。所以 `pas[1]` 就是 `tell` 数组后面 10（数组长度）个 `short` 类型大小的位置的地址。这通常是一个不安全的操作，因为这个地址可能没有被程序合法地分配。访问这个地址通常会导致未定义的行为。

此外，sizeof(pointer)与sizeof(*sizeof)也是不同的。前者是查询储存该指针本身所需的字节长度，比如4字节或8字节。而后者是查询指针指向的数据类型的大小。



###### keyword `static`

在类定义中直接声明的变量通常是非静态成员变量。每个类的对象都有其自己的一份非静态成员变量的拷贝。相对的，静态成员变量是属于类本身的，不属于对象，所有该类的对象共享同一份静态成员变量。

```c++
class Example {
public:
    int a; // 非静态成员变量
    static int b; // 静态成员变量
};
```

非常量引用不可绑定或传入常量：

当一个引用没有被const修饰，不能用这个引用去绑定常量值，因为这意味着你可能会通过这个引用来修改引用的值，但是这与常量不可变的特性是冲突的，如：

```c++
const int x = 10;
// invalid
int &ref = x;

void func(int &a){};
const int constVar = 10;
int nonConstVar = 10;

func(constVar); // invalid
func(nonConstVar); // valid
```



# My Notes

###### keyword const

1）创建变量时修饰： const Example obj；

目的：

- 对象的所以非static成员变量都不可被修改，除非是被mutable修饰的。
- 限制为const的对象只能调用const函数，确保成员函数不会修改对象的状态；
- 当对象作为函数的参数被传入时，确保函数不会修改该对象；
- 有时会对函数返回的对象使用const；
- 明确语义；

2）函数形参const：void func(const &int a)

3）函数声明末尾const：void func(int a) const



###### Member Initialization List 成员初始化列表

不可用于static变量



智能指针



性能优化的一些建议

> 引用传递: 除非有特殊需求，大型对象（例如std::vector, std::deque等）应尽量通过引用进行传递，以避免不必要的拷贝。
>
> const修饰: 如果某个参数或者成员函数不会对对象的状态进行修改，使用const关键字。这样能让编译器进行一些优化，并且使代码更安全。
>
> 预分配内存: 如果知道容器将要存储的元素数量，考虑预先分配容器大小（如std::vector::reserve）。
>
> 函数内联: 对于那些小型且频繁调用的函数，考虑使用内联（inline）以减少函数调用的开销。
>
> 优化数据结构: 考虑数据访问模式，使用最适合的数据结构。例如，在大量查找操作中使用哈希表。
>
> 避免全局变量: 全局变量会影响代码的模块性和可预测性，应尽量避免。
>
> 多线程: 如果有一些独立的计算密集型任务，可以考虑使用多线程进行优化。
>
> 算法复杂性: 选择时间复杂性更优的算法可以大幅提升程序性能。
>
> 延迟初始化: 仅在必要时进行资源的初始化和分配。
>
> 局部性原理: 尽量优化数据的局部性访问，特别是在循环等操作中。
>
> RAII: 资源获取即初始化（RAII）是C++中一种常用的资源管理和异常安全的设计模式，可考虑其用于资源的自动管理。
>
> 使用现代C++特性: 比如auto关键字、范围基础的for循环等，它们不仅可以简化代码，还有助于编译器进行优化。



###### keyword assert

用于开发阶段的调试。

###### keyword noexcept

加上noexcept的函数将承诺不会抛出异常。如果真的存在异常，将会导致整个程序停止。主要是为了告诉编译器，使编译器进行优化，让编译器知道这里绝不会抛异常，不必多生成保护栈上对象安全析构的代码。

###### =default

###### using与typedef的区别

using支持模板别名，而typedef不可

```C++
template <typename T>
using Vec = std::vector<T>;
```

可读性更好，顺序更自然

```c++
using IntPtr = int*;
typedef int* IntPtr;
```

 嵌套类型时using更直观 

```c++
typedef void (*Func)(int, int);
using Func = void (*)(int, int);

// 函数表功能
typedef int (*OperationFuncPtr)(int, int);
int multiply(int a, int b) {
    return a * b;
}

OperationFuncPtr operations[] = {add, multiply};

int result1 = operations[0](3, 4);  // 3 + 4 = 7
int result2 = operations[1](3, 4);  // 3 * 4 = 12

// 回调
void execute(AddFuncPtr func, int a, int b) {
    int result = func(a, b);
    std::cout << "Result: " << result << std::endl;
}

// 成员函数指针
class MyClass {
public:
    void myMethod(int a) {
        std::cout << "Value: " << a << std::endl;
    }
};

using MethodPtr = void (MyClass::*)(int);

MyClass obj;
MethodPtr ptr = &MyClass::myMethod;
(obj.*ptr)(5);  // 输出 "Value: 5"


```

Using可以用来引入基类的名称，从而实现函数重载，否则同名不同参的函数在子类中，基类函数会被隐藏，强行调用（如传入基类函数声明的参数类型，会报错）

```c++
class Base {
public:
  void someMethod(int a) {
  }
};


class Derived : public Base {
public:
	using Base::someMethod;
  void someMethod(double d){}
};
```



###### Memory Pool



# Effective C++

## 06: Explicitly disallow the use of compiler-generated functions you do not want

明确拒绝我们不想使用的编译器自动生成的函数

不声明copy构造函数或copy assignment操作符，编译器可能会自动产出一份，于是class支持了copying。但是如果我们就是不希望class支持copying呢？

关键在于：编译器自动产出的函数都是public的，因此一个解决方案是令这些函数为private，从而阻止外部的调用。

这个方法不是绝对的安全，因为member函数和friend函数都可以调用private函数。

可以声明一个基类来专门负责：

```c++
class Uncopyable {
protected:
    Uncopyale() {};  // 允许子类对象构造和析构
    ~Uncopyable() {}; // 注意这里不一定得是virtual的，见条款07
private:
    Uncopyable(const Uncopyable&); // 阻止copy
    Uncopyable& operator=(const Uncopyable&);
}

class HomeForSale: private Uncopyable { // private使得基类的public和protected成员在子类中变为私有成员
    ... // class不需要再声明copy构造函数和copy赋值运算符为private
}
```

> 你认为uncopyable这个基类的析构函数不需要是virtual的原因有哪些？
>
> ChatGPT
>
> 在此情况下，`Uncopyable`基类的析构函数不需要是`virtual`的，主要有以下几个原因：
>
> 1. **非多态基类**： `Uncopyable`的目的是为了禁止复制和赋值，而不是为了提供多态行为。通常，只有当基类打算被用作多态基类时，析构函数才需要是`virtual`的。
> 2. **无需基类指针**： `Uncopyable`基类没有任何其他的成员函数，也不包含任何可重写的虚函数。因此，很少有情况需要通过指向`Uncopyable`的指针或引用来操作`HomeForSale`对象。无需通过基类指针删除派生类对象，所以不需要`virtual`析构函数。
> 3. **无资源管理**： `Uncopyable`基类不包含任何资源（如动态分配的内存），也没有定义任何实际的析构逻辑。因此，即使析构函数不是`virtual`的，也不会出现资源泄露的问题。
> 4. **减少虚表开销**： 为基类定义`virtual`析构函数会为该类添加一个虚表（vtable）。虚表是一个存储类的虚函数地址的表，它会增加每个对象的大小，并可能稍微降低性能。在这种情况下，由于`Uncopyable`的目的是为了提供禁止复制和赋值的能力，而不是为了提供多态行为，所以没有必要为它增加虚表的开销。
>
> 综上所述，`Uncopyable`基类的析构函数不需要是`virtual`的，因为它不是为了提供多态行为，而是为了禁止复制和赋值。

BTW，about private继承所带来的：子类继承了基类的实现，但并不继承基类的接口，如何理解？<mark>子类内部可访问基类成员，但子类对象不能调用。</mark>

```c++
class Base {
public:
    void baseFunction() {
        std::cout << "Base function called" << std::endl;
    }
};

class Derived : private Base {
public:
    void derivedFunction() {
        baseFunction();  // 正确：在Derived内部可以访问Base的成员
    }
};

int main() {
    Derived d;
    d.derivedFunction();  // 输出：Base function called
    // d.baseFunction();  // 错误：baseFunction在Derived中是私有的
    return 0;
}
```

如果一定想调用呢？通过创建一个新方法，或使用using声明：

```c++
class Base {
public:
    void baseFunction() {
        std::cout << "Base function called" << std::endl;
    }
};

class Derived : private Base {
public:
    using Base::baseFunction;  // 使用 using 声明使 baseFunction 在 Derived 类中可访问

    void derivedFunction() {
        baseFunction();  // 现在这是正确的
    }
};

int main() {
    Derived d;
    d.derivedFunction();  // 输出：Base function called
    d.baseFunction();  // 现在这也是正确的
    return 0;
}
```





## 07: Declare destructors virtual in polymorphic base classes

polymorphic base classes should declare a virtual destructor. 并且如果class中带有任何virtual函数，那么它就应该拥有一个virtual析构函数；

classes的设计目的如果不是作为base classes使用，或不是为了多态，就不该声明virtual函数

比如有一个记录时间的基类TimeKeeper，可能会有多种子类，AtomicClock，WaterClock，WristClock。并设计了一个工厂函数提供一个计时对象，工厂函数会返回一个base class指针，指向derived class对象。

```c++
class TimeKeeper() {
public:
    TimeKeeper();
    ~TimeKeeper(); // non-virtual
};

class AtomicClock: public TimeKeeper {...};
class WaterClock: public TimeKeeper {...};
class WristClock: public TimeKeeper {...};

TimeKeeper* getTimeKeeper();

// 为了遵守factory函数的规矩，被该函数返回的对象必须是在堆区。为了避免内存泄漏，需要delete
...
delete ptk;


```

条款13认为依赖于客户执行delete动作，本身就具有某种错误倾向；

此处更严重的问题是，工厂函数返回的指针指向一个derived class对象比如AtomicClock对象，但是对象却经由一个base class指针比如TimeKeeper* 来删除，而当前基类的析构函数是non-virtual的。会导致：<mark>对象的derived成分没被销毁，子类的析构函数也未能被运行，导致诡异的局部销毁，从而造成资源泄露</mark>。因此修改：

```c++
class TimeKeeper() {
public:
    TimeKeeper();
    virtual ~TimeKeeper(); //virtual
};
```

此外，像TimeKeeper这样的基类一般还会有除了析构函数以外的其他virtual函数，比如`virtual getCurrentTime`，在不同的子类中应该有不同的实现。再次强调：任何class只要带有virtual函数几乎确定也应该有一个virtual destructor。如果不打算将其作为base class，一般不需要使用virtual。

<u>即使class完全没有virtual函数，non-virtual析构函数有时候也会带来问题</u>：比如继承标准库的一些类如string，其析构函数是non-virtual的。

```c++
class SpecialString: puhblic std::string { // Really awful! }
```

假如程序无意中将一个pointer-to-SpecialString转换为pointer-to-string，并将转换所得的指针delete掉，就会导致行为不明确。

```c++
SpecialString* pss = new SpecialString("Impending Doom");
std::string* ps;
...
ps = pss; // 向上转型
...
delete ps; // 未定义！SpecialString的析构函数没有被调用
```

C++并没有像java一样的final关键字来禁止派生

<mark>关于pure virtual析构函数，必须为其提供定义</mark>。这个会在一些场景下提供一些便利，但是pure virtual会导致类变成抽象基类，无法实例化。析构函数的运作顺序：从most derived的类开始被调用，然后依次到最顶上的base class的析构函数。因此，编译器会在AWOV的derived classes的析构函数中创建一个对~AWOV的调用动作，因此必须提供一个定义。否则导致链接错误。

```c++
class AWOV {
public:
    virtual ~AWOV() = 0;  // 纯虚析构函数
};

AWOV::~AWOV() {}  // 纯虚析构函数的定义
```

